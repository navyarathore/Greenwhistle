{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {IERC721Enumerable} from \"./IERC721Enumerable.sol\";\nimport {IERC165} from \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds enumerability\n * of all the token ids in the contract as well as all token ids owned by each account.\n *\n * CAUTION: `ERC721` extensions that implement custom `balanceOf` logic, such as `ERC721Consecutive`,\n * interfere with enumerability and should not be used together with `ERC721Enumerable`.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\n\n    uint256[] private _allTokens;\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\n\n    /**\n     * @dev An `owner`'s token query was out of bounds for `index`.\n     *\n     * NOTE: The owner being `address(0)` indicates a global out of bounds index.\n     */\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\n\n    /**\n     * @dev Batch mint is not allowed.\n     */\n    error ERC721EnumerableForbiddenBatchMint();\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256) {\n        if (index >= balanceOf(owner)) {\n            revert ERC721OutOfBoundsIndex(owner, index);\n        }\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\n        if (index >= totalSupply()) {\n            revert ERC721OutOfBoundsIndex(address(0), index);\n        }\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_update}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n        address previousOwner = super._update(to, tokenId, auth);\n\n        if (previousOwner == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (previousOwner != to) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        return previousOwner;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to) - 1;\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch\n     */\n    function _increaseBalance(address account, uint128 amount) internal virtual override {\n        if (amount > 0) {\n            revert ERC721EnumerableForbiddenBatchMint();\n        }\n        super._increaseBalance(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Strings} from \"../../../utils/Strings.sol\";\nimport {IERC4906} from \"../../../interfaces/IERC4906.sol\";\nimport {IERC165} from \"../../../interfaces/IERC165.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\n    using Strings for uint256;\n\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\n    // defines events and does not include any external function.\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n\n    // Optional mapping for token URIs\n    mapping(uint256 tokenId => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/GameNfts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721URIStorage } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport { Counters } from \"openzeppelin/contracts/utils/Counters.sol\";\n\ncontract GameNfts is ERC721Enumerable, ERC721URIStorage, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    // Struct to store NFT metadata\n    struct NFTMetadata {\n        string earningReason;\n        uint256 earnedTimestamp;\n        string imageURI; // Direct URI to the NFT image\n        string additionalData; // JSON string for any additional data\n        string rarity; // Rarity level (common, uncommon, rare, epic, legendary, unique)\n    }\n\n    // Mapping from token ID to metadata\n    mapping(uint256 => NFTMetadata) private _nftMetadata;\n\n    // Events\n    event NFTMinted(address indexed to, uint256 indexed tokenId, string reason, string imageURI);\n    event MetadataUpdated(uint256 indexed tokenId, string newURI);\n    event ImageURIUpdated(uint256 indexed tokenId, string newImageURI);\n    event NFTTransferred(address indexed from, address indexed to, uint256 indexed tokenId);\n    event BatchNFTTransferred(address indexed from, address indexed to, uint256[] tokenIds);\n\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) Ownable(msg.sender) {}\n\n    // Mint new NFT with specified earning reason and image\n    function mintNFT(\n        address recipient,\n        string memory tokenURI,\n        string memory imageURI,\n        string memory reason,\n        string memory additionalData,\n        string memory rarity\n    ) public onlyOwner returns (uint256) {\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n\n        _safeMint(recipient, newTokenId);\n        _setTokenURI(newTokenId, tokenURI);\n\n        _nftMetadata[newTokenId] = NFTMetadata({\n            earningReason: reason,\n            earnedTimestamp: block.timestamp,\n            imageURI: imageURI,\n            additionalData: additionalData,\n            rarity: rarity\n        });\n\n        emit NFTMinted(recipient, newTokenId, reason, imageURI);\n\n        return newTokenId;\n    }\n\n    // Batch mint NFTs to a recipient\n    function batchMintNFTs(\n        address recipient,\n        string[] memory tokenURIs,\n        string[] memory imageURIs,\n        string memory reason,\n        string memory additionalData,\n        string memory rarity\n    ) public onlyOwner returns (uint256[] memory) {\n        require(tokenURIs.length > 0, \"Must mint at least one NFT\");\n        require(tokenURIs.length == imageURIs.length, \"Token and image arrays must have same length\");\n\n        uint256[] memory tokenIds = new uint256[](tokenURIs.length);\n\n        for (uint256 i = 0; i < tokenURIs.length; i++) {\n            tokenIds[i] = mintNFT(recipient, tokenURIs[i], imageURIs[i], reason, additionalData, rarity);\n        }\n\n        return tokenIds;\n    }\n\n    // Update token URI\n    function updateTokenURI(uint256 tokenId, string memory newTokenURI) public onlyOwner {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        _setTokenURI(tokenId, newTokenURI);\n        emit MetadataUpdated(tokenId, newTokenURI);\n    }\n\n    // Update image URI\n    function updateImageURI(uint256 tokenId, string memory newImageURI) public onlyOwner {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        _nftMetadata[tokenId].imageURI = newImageURI;\n        emit ImageURIUpdated(tokenId, newImageURI);\n    }\n\n    // Transfer NFT\n    function transferNFT(address from, address to, uint256 tokenId) public {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        require(\n            from == msg.sender || getApproved(tokenId) == msg.sender || isApprovedForAll(from, msg.sender),\n            \"Caller is not owner nor approved\"\n        );\n\n        safeTransferFrom(from, to, tokenId);\n        emit NFTTransferred(from, to, tokenId);\n    }\n\n    // Batch transfer NFTs\n    function batchTransferNFTs(address from, address to, uint256[] memory tokenIds) public {\n        require(tokenIds.length > 0, \"Must transfer at least one NFT\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n            require(\n                from == msg.sender || getApproved(tokenId) == msg.sender || isApprovedForAll(from, msg.sender),\n                \"Caller is not owner nor approved for one or more tokens\"\n            );\n\n            safeTransferFrom(from, to, tokenId);\n        }\n\n        emit BatchNFTTransferred(from, to, tokenIds);\n    }\n\n    // Game master controlled transfer (owner can force transfer NFTs between addresses)\n    function gameMasterTransfer(address from, address to, uint256 tokenId) public onlyOwner {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        require(ownerOf(tokenId) == from, \"From address is not the owner\");\n\n        _safeTransfer(from, to, tokenId, \"\");\n        emit NFTTransferred(from, to, tokenId);\n    }\n\n    // Game master controlled batch transfer\n    function gameMasterBatchTransfer(address from, address to, uint256[] memory tokenIds) public onlyOwner {\n        require(tokenIds.length > 0, \"Must transfer at least one NFT\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n            require(ownerOf(tokenId) == from, \"From address is not the owner of one or more tokens\");\n\n            _safeTransfer(from, to, tokenId, \"\");\n        }\n\n        emit BatchNFTTransferred(from, to, tokenIds);\n    }\n\n    // Get NFT metadata\n    function getNFTMetadata(\n        uint256 tokenId\n    )\n        public\n        view\n        returns (\n            string memory earningReason,\n            uint256 earnedTimestamp,\n            string memory imageURI,\n            string memory additionalData,\n            string memory rarity\n        )\n    {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        NFTMetadata memory metadata = _nftMetadata[tokenId];\n        return (\n            metadata.earningReason,\n            metadata.earnedTimestamp,\n            metadata.imageURI,\n            metadata.additionalData,\n            metadata.rarity\n        );\n    }\n\n    // Get image URI\n    function getImageURI(uint256 tokenId) public view returns (string memory) {\n        require(_ownerOf(tokenId) != address(0), \"Token does not exist\");\n        return _nftMetadata[tokenId].imageURI;\n    }\n\n    // Get all tokens owned by an address\n    function getTokensByOwner(address owner) public view returns (uint256[] memory) {\n        uint256 tokenCount = balanceOf(owner);\n\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        }\n\n        uint256[] memory result = new uint256[](tokenCount);\n        for (uint256 i = 0; i < tokenCount; i++) {\n            result[i] = tokenOfOwnerByIndex(owner, i);\n        }\n\n        return result;\n    }\n\n    // Get all NFTs in the contract (for owner only)\n    function getAllNFTs() public view onlyOwner returns (uint256[] memory) {\n        uint256 totalSupply = totalSupply();\n        uint256[] memory result = new uint256[](totalSupply);\n\n        for (uint256 i = 0; i < totalSupply; i++) {\n            result[i] = tokenByIndex(i);\n        }\n\n        return result;\n    }\n\n    // Get total count of NFTs\n    function getTotalNFTs() public view returns (uint256) {\n        return _tokenIds.current();\n    }\n\n    // Override functions required by inherited contracts\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override(ERC721, ERC721Enumerable) returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n\n    function _increaseBalance(address account, uint128 amount) internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(account, amount);\n    }\n\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(ERC721Enumerable, ERC721URIStorage) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/GameSave.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title GameSave\n * @dev Contract for saving and loading game data to/from the blockchain\n */\ncontract GameSave is Ownable, ReentrancyGuard, Pausable {\n    // Game data structure\n    struct SaveData {\n        uint256 version;\n        uint256 timestamp;\n        // Player data\n        PlayerData player;\n        // Arrays for different game elements\n        InventoryItem[] inventory;\n        FarmingData[] farming;\n        MapChange[] mapChanges;\n    }\n\n    // Player data structure\n    struct PlayerData {\n        uint256 positionX;\n        uint256 positionY;\n        uint256 health;\n        uint256 selectedHotbarSlot;\n    }\n\n    // Inventory item structure\n    struct InventoryItem {\n        uint256 slotIndex;\n        string itemId;\n        uint256 quantity;\n    }\n\n    // Farming data structure\n    struct FarmingData {\n        uint256 positionX;\n        uint256 positionY;\n        string cropId;\n        uint256 growthStage;\n        uint256 plantedTime;\n        uint256 lastWateredTime;\n    }\n\n    // Map change structure\n    struct MapChange {\n        string layer;\n        uint256 positionX;\n        uint256 positionY;\n        int256 tileIndex;\n    }\n\n    // Mapping from address to save data\n    mapping(address => SaveData) private gameSaves;\n    mapping(address => bool) private hasSave;\n\n    // Events\n    event GameSaved(address indexed player, uint256 timestamp);\n    event SaveDeleted(address indexed player);\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Save game data to the blockchain\n     */\n    function saveGame(\n        uint256 _version,\n        uint256 _timestamp,\n        PlayerData calldata _player,\n        InventoryItem[] calldata _inventory,\n        FarmingData[] calldata _farming,\n        MapChange[] calldata _mapChanges\n    ) external whenNotPaused nonReentrant {\n        SaveData storage saveData = gameSaves[msg.sender];\n\n        saveData.version = _version;\n        saveData.timestamp = _timestamp;\n        saveData.player = _player;\n\n        // Clear existing arrays and replace with new data\n        delete saveData.inventory;\n        delete saveData.farming;\n        delete saveData.mapChanges;\n\n        // Save inventory items\n        for (uint i = 0; i < _inventory.length; i++) {\n            saveData.inventory.push(_inventory[i]);\n        }\n\n        // Save farming data\n        for (uint i = 0; i < _farming.length; i++) {\n            saveData.farming.push(_farming[i]);\n        }\n\n        // Save map changes\n        for (uint i = 0; i < _mapChanges.length; i++) {\n            saveData.mapChanges.push(_mapChanges[i]);\n        }\n\n        hasSave[msg.sender] = true;\n\n        emit GameSaved(msg.sender, _timestamp);\n    }\n\n    function loadGame()\n        external\n        view\n        whenNotPaused\n        returns (\n            uint256 version,\n            uint256 timestamp,\n            PlayerData memory player,\n            InventoryItem[] memory inventory,\n            FarmingData[] memory farming,\n            MapChange[] memory mapChanges\n        )\n    {\n        require(hasSave[msg.sender], \"No save data found for this address\");\n\n        SaveData storage saveData = gameSaves[msg.sender];\n\n        return (\n            saveData.version,\n            saveData.timestamp,\n            saveData.player,\n            saveData.inventory,\n            saveData.farming,\n            saveData.mapChanges\n        );\n    }\n\n    /**\n     * @dev Check if the player has a saved game\n     * @return Whether the player has a saved game\n     */\n    function hasSaveData() external view returns (bool) {\n        return hasSave[msg.sender];\n    }\n\n    /**\n     * @dev Delete the current save\n     */\n    function deleteSaveData() external whenNotPaused nonReentrant {\n        require(hasSave[msg.sender], \"No save data found for this address\");\n\n        delete gameSaves[msg.sender];\n        hasSave[msg.sender] = false;\n\n        emit SaveDeleted(msg.sender);\n    }\n\n    /**\n     * @dev Pause the contract (only owner)\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract (only owner)\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/GameToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title GameToken\n * @dev Implements a basic ERC20 token for use in a game with enhanced balance tracking\n */\ncontract GameToken is ERC20, Ownable {\n    uint8 private immutable _decimals;\n\n    // Additional user data structure\n    struct UserData {\n        uint256 totalEarned;\n        uint256 totalSpent;\n        uint256 lastUpdateTime;\n    }\n\n    // Mapping to track additional user data\n    mapping(address => UserData) private _userData;\n\n    /**\n     * @dev Constructor that gives the msg.sender all initial tokens.\n     * @param initialSupply Initial supply of tokens\n     * @param name_ Name of the token\n     * @param symbol_ Symbol of the token\n     * @param decimals_ Number of decimals for the token\n     */\n    constructor(\n        uint256 initialSupply,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) Ownable(msg.sender) {\n        _decimals = decimals_;\n        _mint(msg.sender, initialSupply);\n\n        // Initialize user data for the initial holder\n        _userData[msg.sender].totalEarned = initialSupply;\n        _userData[msg.sender].lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @dev Returns the number of decimals used for token.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Mints new tokens to an address and updates user stats.\n     * @param to The address that will receive the minted tokens\n     * @param amount The amount of tokens to mint\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n        _userData[to].totalEarned += amount;\n        _userData[to].lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @dev Burns tokens from an address and updates user stats.\n     * @param from The address from which to burn tokens\n     * @param amount The amount of tokens to burn\n     */\n    function burn(address from, uint256 amount) external {\n        require(from == msg.sender || owner() == msg.sender, \"GameToken: Caller must be owner or burning own tokens\");\n        _burn(from, amount);\n        _userData[from].totalSpent += amount;\n        _userData[from].lastUpdateTime = block.timestamp;\n    }\n\n    /**\n     * @dev Returns detailed user balance data\n     * @param user The address of the user\n     * @return currentBalance The current token balance\n     * @return totalEarned Total tokens earned/received\n     * @return totalSpent Total tokens spent/burned\n     * @return lastUpdateTime Last time user data was updated\n     */\n    function getUserData(\n        address user\n    ) external view returns (uint256 currentBalance, uint256 totalEarned, uint256 totalSpent, uint256 lastUpdateTime) {\n        return (\n            balanceOf(user),\n            _userData[user].totalEarned,\n            _userData[user].totalSpent,\n            _userData[user].lastUpdateTime\n        );\n    }\n\n    /**\n     * @dev Override the _update function to track user stats on transfers\n     */\n    function _update(address from, address to, uint256 amount) internal override {\n        super._update(from, to, amount);\n\n        // Skip minting and burning as they're handled in their respective functions\n        if (from != address(0) && to != address(0)) {\n            _userData[to].totalEarned += amount;\n            _userData[from].totalSpent += amount;\n            _userData[to].lastUpdateTime = block.timestamp;\n            _userData[from].lastUpdateTime = block.timestamp;\n        }\n    }\n}\n"
    },
    "contracts/VolatileMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { Counters } from \"openzeppelin/contracts/utils/Counters.sol\";\nimport \"./GameToken.sol\";\nimport \"./GameNfts.sol\";\nimport \"./GameSave.sol\";\n\n/**\n * @title VolatileMarketplace\n * @dev A marketplace contract for trading in-game items and NFTs with supply and demand dynamics\n * similar to the Steam marketplace. All transactions are conducted with game tokens.\n */\ncontract VolatileMarketplace is Ownable, ReentrancyGuard, Pausable {\n    using Counters for Counters.Counter;\n\n    // Contract dependencies\n    GameToken public gameToken;\n    GameNfts public gameNfts;\n    GameSave public gameSave;\n\n    // Listing counter\n    Counters.Counter private _listingIds;\n\n    // Fee structure\n    uint256 public marketplaceFeePercentage = 250; // 2.5% (using basis points: 10000 = 100%)\n    address public feeCollector;\n\n    // Marketplace types\n    enum ItemType {\n        GAME_ITEM,\n        NFT\n    }\n\n    // Listing structure\n    struct Listing {\n        uint256 listingId;\n        address seller;\n        string gameItemId; // For game items\n        uint256 nftId; // For NFTs\n        uint256 quantity; // For game items (always 1 for NFTs)\n        uint256 price; // Price per unit in game tokens\n        uint256 listedAt;\n        bool active;\n        ItemType itemType;\n    }\n\n    // History of sold items for price tracking\n    struct SaleRecord {\n        uint256 timestamp;\n        uint256 price;\n        uint256 quantity;\n    }\n\n    // Market statistics\n    struct MarketStats {\n        uint256 totalVolume; // Total volume traded\n        uint256 highestPrice; // Highest price ever sold\n        uint256 lowestPrice; // Lowest price ever sold (if not 0)\n        uint256 lastSoldPrice; // Last sold price\n        uint256 numberOfSales; // Number of completed sales\n        uint256 totalListings; // Total times listed\n        uint256 currentListings; // Current active listings count\n        uint256 avgSoldPrice; // Average selling price (rolling)\n    }\n\n    // Mappings\n    mapping(uint256 => Listing) public listings;\n    mapping(address => uint256[]) public sellerListings;\n    mapping(string => MarketStats) public gameItemStats;\n    mapping(uint256 => MarketStats) public nftStats;\n    mapping(string => SaleRecord[]) public gameItemSaleHistory;\n    mapping(uint256 => SaleRecord[]) public nftSaleHistory;\n\n    // Keep track of the current lowest priced listing for each item\n    mapping(string => uint256) public lowestPriceListingForGameItem;\n    mapping(uint256 => uint256) public lowestPriceListingForNft;\n\n    // Track unique game items and NFTs that are listed\n    mapping(string => bool) public listedGameItems;\n    mapping(uint256 => bool) public listedNfts;\n    string[] public uniqueGameItemIds;\n    uint256[] public uniqueNftIds;\n\n    // Events\n    event ItemListed(\n        uint256 indexed listingId,\n        address indexed seller,\n        string gameItemId,\n        uint256 price,\n        uint256 quantity,\n        ItemType itemType\n    );\n    event NftListed(\n        uint256 indexed listingId,\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        ItemType itemType\n    );\n    event ListingCancelled(uint256 indexed listingId, address indexed seller);\n    event ItemSold(\n        uint256 indexed listingId,\n        address indexed seller,\n        address indexed buyer,\n        string gameItemId,\n        uint256 price,\n        uint256 quantity\n    );\n    event NftSold(\n        uint256 indexed listingId,\n        address indexed seller,\n        address indexed buyer,\n        uint256 nftId,\n        uint256 price\n    );\n    event MarketplaceFeeUpdated(uint256 newFeePercentage);\n    event FeeCollectorUpdated(address newFeeCollector);\n    event PriceChanged(uint256 indexed listingId, uint256 oldPrice, uint256 newPrice);\n\n    /**\n     * @dev Constructor to initialize the marketplace with required contract addresses\n     * @param _gameToken Address of the game token contract\n     * @param _gameNfts Address of the game NFTs contract\n     * @param _gameSave Address of the game save contract\n     */\n    constructor(address _gameToken, address _gameNfts, address _gameSave) Ownable(msg.sender) {\n        require(_gameToken != address(0), \"Invalid GameToken address\");\n        require(_gameNfts != address(0), \"Invalid GameNfts address\");\n        require(_gameSave != address(0), \"Invalid GameSave address\");\n\n        gameToken = GameToken(_gameToken);\n        gameNfts = GameNfts(_gameNfts);\n        gameSave = GameSave(_gameSave);\n\n        feeCollector = msg.sender;\n    }\n\n    /**\n     * @dev List a game item on the marketplace\n     * @param gameItemId The ID of the game item as used in the game\n     * @param quantity The quantity of the item to list\n     * @param price The price per unit in game tokens\n     */\n    function listGameItem(\n        string memory gameItemId,\n        uint256 quantity,\n        uint256 price\n    ) external whenNotPaused nonReentrant {\n        require(quantity > 0, \"Quantity must be greater than 0\");\n        require(price > 0, \"Price must be greater than 0\");\n\n        // Verify that the user has the item in their inventory\n        bool hasItem = _verifyGameItemOwnership(msg.sender, gameItemId, quantity);\n        require(hasItem, \"You don't own enough of this item\");\n\n        // Create the listing\n        _listingIds.increment();\n        uint256 newListingId = _listingIds.current();\n\n        listings[newListingId] = Listing({\n            listingId: newListingId,\n            seller: msg.sender,\n            gameItemId: gameItemId,\n            nftId: 0,\n            quantity: quantity,\n            price: price,\n            listedAt: block.timestamp,\n            active: true,\n            itemType: ItemType.GAME_ITEM\n        });\n\n        // Add to seller's listings\n        sellerListings[msg.sender].push(newListingId);\n\n        // Update market stats\n        gameItemStats[gameItemId].totalListings++;\n        gameItemStats[gameItemId].currentListings++;\n\n        // Track unique game item if not already tracked\n        if (!listedGameItems[gameItemId]) {\n            listedGameItems[gameItemId] = true;\n            uniqueGameItemIds.push(gameItemId);\n        }\n\n        // Update lowest price listing if applicable\n        _updateLowestPriceGameItemListing(gameItemId, newListingId, price);\n\n        // Track unique game items\n        if (!listedGameItems[gameItemId]) {\n            listedGameItems[gameItemId] = true;\n            uniqueGameItemIds.push(gameItemId);\n        }\n\n        emit ItemListed(newListingId, msg.sender, gameItemId, price, quantity, ItemType.GAME_ITEM);\n    }\n\n    /**\n     * @dev List an NFT on the marketplace\n     * @param nftId The token ID of the NFT\n     * @param price The price in game tokens\n     */\n    function listNft(uint256 nftId, uint256 price) external whenNotPaused nonReentrant {\n        require(price > 0, \"Price must be greater than 0\");\n\n        // Verify that the user owns the NFT\n        require(gameNfts.ownerOf(nftId) == msg.sender, \"You don't own this NFT\");\n\n        // Check if the NFT is approved for the marketplace\n        require(\n            gameNfts.getApproved(nftId) == address(this) || gameNfts.isApprovedForAll(msg.sender, address(this)),\n            \"NFT not approved for marketplace\"\n        );\n\n        // Create the listing\n        _listingIds.increment();\n        uint256 newListingId = _listingIds.current();\n\n        listings[newListingId] = Listing({\n            listingId: newListingId,\n            seller: msg.sender,\n            gameItemId: \"\",\n            nftId: nftId,\n            quantity: 1, // NFTs always have quantity of 1\n            price: price,\n            listedAt: block.timestamp,\n            active: true,\n            itemType: ItemType.NFT\n        });\n\n        // Add to seller's listings\n        sellerListings[msg.sender].push(newListingId);\n\n        // Update market stats\n        nftStats[nftId].totalListings++;\n        nftStats[nftId].currentListings++;\n\n        // Track unique NFT if not already tracked\n        if (!listedNfts[nftId]) {\n            listedNfts[nftId] = true;\n            uniqueNftIds.push(nftId);\n        }\n\n        // Update lowest price listing if applicable\n        _updateLowestPriceNftListing(nftId, newListingId, price);\n\n        // Track unique NFTs\n        if (!listedNfts[nftId]) {\n            listedNfts[nftId] = true;\n            uniqueNftIds.push(nftId);\n        }\n\n        emit NftListed(newListingId, msg.sender, nftId, price, ItemType.NFT);\n    }\n\n    /**\n     * @dev Cancel a listing\n     * @param listingId The ID of the listing to cancel\n     */\n    function cancelListing(uint256 listingId) external nonReentrant {\n        Listing storage listing = listings[listingId];\n\n        require(listing.active, \"Listing is not active\");\n        require(listing.seller == msg.sender || owner() == msg.sender, \"Not authorized\");\n\n        listing.active = false;\n\n        // Update market stats\n        if (listing.itemType == ItemType.GAME_ITEM) {\n            gameItemStats[listing.gameItemId].currentListings--;\n\n            // Check if this was the last listing for this item and remove from unique items if so\n            if (gameItemStats[listing.gameItemId].currentListings == 0) {\n                _removeUniqueGameItem(listing.gameItemId);\n            }\n\n            // Update lowest price listing if this was the lowest price\n            if (lowestPriceListingForGameItem[listing.gameItemId] == listingId) {\n                _recalculateLowestPriceGameItemListing(listing.gameItemId);\n            }\n        } else {\n            nftStats[listing.nftId].currentListings--;\n\n            // Check if this was the last listing for this NFT and remove from unique items if so\n            if (nftStats[listing.nftId].currentListings == 0) {\n                _removeUniqueNft(listing.nftId);\n            }\n\n            // Update lowest price listing if this was the lowest price\n            if (lowestPriceListingForNft[listing.nftId] == listingId) {\n                _recalculateLowestPriceNftListing(listing.nftId);\n            }\n        }\n\n        emit ListingCancelled(listingId, msg.sender);\n    }\n\n    /**\n     * @dev Change the price of a listing\n     * @param listingId The ID of the listing\n     * @param newPrice The new price\n     */\n    function changeListingPrice(uint256 listingId, uint256 newPrice) external nonReentrant {\n        require(newPrice > 0, \"Price must be greater than 0\");\n\n        Listing storage listing = listings[listingId];\n\n        require(listing.active, \"Listing is not active\");\n        require(listing.seller == msg.sender, \"Not the seller\");\n\n        uint256 oldPrice = listing.price;\n        listing.price = newPrice;\n\n        // Update lowest price listing if necessary\n        if (listing.itemType == ItemType.GAME_ITEM) {\n            if (lowestPriceListingForGameItem[listing.gameItemId] == listingId && newPrice > oldPrice) {\n                _recalculateLowestPriceGameItemListing(listing.gameItemId);\n            } else if (newPrice < _getLowestPriceForGameItem(listing.gameItemId)) {\n                _updateLowestPriceGameItemListing(listing.gameItemId, listingId, newPrice);\n            }\n        } else {\n            if (lowestPriceListingForNft[listing.nftId] == listingId && newPrice > oldPrice) {\n                _recalculateLowestPriceNftListing(listing.nftId);\n            } else if (newPrice < _getLowestPriceForNft(listing.nftId)) {\n                _updateLowestPriceNftListing(listing.nftId, listingId, newPrice);\n            }\n        }\n\n        emit PriceChanged(listingId, oldPrice, newPrice);\n    }\n\n    /**\n     * @dev Buy a game item from the marketplace\n     * @param listingId The ID of the listing\n     * @param quantity The quantity to buy (must be <= listing quantity)\n     */\n    function buyGameItem(uint256 listingId, uint256 quantity) external whenNotPaused nonReentrant {\n        Listing storage listing = listings[listingId];\n\n        require(listing.active, \"Listing is not active\");\n        require(listing.itemType == ItemType.GAME_ITEM, \"Not a game item\");\n        require(quantity > 0 && quantity <= listing.quantity, \"Invalid quantity\");\n        require(listing.seller != msg.sender, \"Cannot buy your own listing\");\n\n        uint256 totalPrice = listing.price * quantity;\n        uint256 fee = (totalPrice * marketplaceFeePercentage) / 10000;\n        uint256 sellerAmount = totalPrice - fee;\n\n        // Check if buyer has enough tokens\n        require(gameToken.balanceOf(msg.sender) >= totalPrice, \"Insufficient funds\");\n\n        // Transfer tokens from buyer to seller and marketplace\n        require(gameToken.transferFrom(msg.sender, listing.seller, sellerAmount), \"Token transfer to seller failed\");\n        require(gameToken.transferFrom(msg.sender, feeCollector, fee), \"Fee transfer failed\");\n\n        // Update listing\n        if (quantity == listing.quantity) {\n            listing.active = false;\n            gameItemStats[listing.gameItemId].currentListings--;\n\n            // Check if this was the last listing for this item and remove from unique items if so\n            if (gameItemStats[listing.gameItemId].currentListings == 0) {\n                _removeUniqueGameItem(listing.gameItemId);\n            }\n\n            // Update lowest price listing if this was the lowest price\n            if (lowestPriceListingForGameItem[listing.gameItemId] == listingId) {\n                _recalculateLowestPriceGameItemListing(listing.gameItemId);\n            }\n        } else {\n            listing.quantity -= quantity;\n        }\n\n        // Record sale in history\n        SaleRecord memory record = SaleRecord({ timestamp: block.timestamp, price: listing.price, quantity: quantity });\n        gameItemSaleHistory[listing.gameItemId].push(record);\n\n        // Update market stats\n        MarketStats storage stats = gameItemStats[listing.gameItemId];\n        stats.totalVolume += totalPrice;\n        stats.numberOfSales++;\n        stats.lastSoldPrice = listing.price;\n\n        // Update highest/lowest price if applicable\n        if (listing.price > stats.highestPrice) {\n            stats.highestPrice = listing.price;\n        }\n        if (stats.lowestPrice == 0 || listing.price < stats.lowestPrice) {\n            stats.lowestPrice = listing.price;\n        }\n\n        // Update average price (simple rolling average)\n        stats.avgSoldPrice = (stats.avgSoldPrice * (stats.numberOfSales - 1) + listing.price) / stats.numberOfSales;\n\n        // Update buyer's inventory (handled off-chain)\n\n        emit ItemSold(listingId, listing.seller, msg.sender, listing.gameItemId, listing.price, quantity);\n    }\n\n    /**\n     * @dev Buy an NFT from the marketplace\n     * @param listingId The ID of the listing\n     */\n    function buyNft(uint256 listingId) external whenNotPaused nonReentrant {\n        Listing storage listing = listings[listingId];\n\n        require(listing.active, \"Listing is not active\");\n        require(listing.itemType == ItemType.NFT, \"Not an NFT\");\n        require(listing.seller != msg.sender, \"Cannot buy your own listing\");\n\n        uint256 totalPrice = listing.price;\n        uint256 fee = (totalPrice * marketplaceFeePercentage) / 10000;\n        uint256 sellerAmount = totalPrice - fee;\n\n        // Check if buyer has enough tokens and NFT is still owned by seller\n        require(gameToken.balanceOf(msg.sender) >= totalPrice, \"Insufficient funds\");\n        require(gameNfts.ownerOf(listing.nftId) == listing.seller, \"Seller no longer owns this NFT\");\n\n        // Transfer tokens from buyer to seller and marketplace\n        require(gameToken.transferFrom(msg.sender, listing.seller, sellerAmount), \"Token transfer to seller failed\");\n        require(gameToken.transferFrom(msg.sender, feeCollector, fee), \"Fee transfer failed\");\n\n        // Transfer NFT from seller to buyer\n        gameNfts.transferFrom(listing.seller, msg.sender, listing.nftId);\n\n        // Update listing\n        listing.active = false;\n        nftStats[listing.nftId].currentListings--;\n\n        // Check if this was the last listing for this NFT and remove from unique items if so\n        if (nftStats[listing.nftId].currentListings == 0) {\n            _removeUniqueNft(listing.nftId);\n        }\n\n        // Update lowest price listing if this was the lowest price\n        if (lowestPriceListingForNft[listing.nftId] == listingId) {\n            _recalculateLowestPriceNftListing(listing.nftId);\n        }\n\n        // Record sale in history\n        SaleRecord memory record = SaleRecord({ timestamp: block.timestamp, price: listing.price, quantity: 1 });\n        nftSaleHistory[listing.nftId].push(record);\n\n        // Update market stats\n        MarketStats storage stats = nftStats[listing.nftId];\n        stats.totalVolume += totalPrice;\n        stats.numberOfSales++;\n        stats.lastSoldPrice = listing.price;\n\n        // Update highest/lowest price if applicable\n        if (listing.price > stats.highestPrice) {\n            stats.highestPrice = listing.price;\n        }\n        if (stats.lowestPrice == 0 || listing.price < stats.lowestPrice) {\n            stats.lowestPrice = listing.price;\n        }\n\n        // Update average price (simple rolling average)\n        stats.avgSoldPrice = (stats.avgSoldPrice * (stats.numberOfSales - 1) + listing.price) / stats.numberOfSales;\n\n        emit NftSold(listingId, listing.seller, msg.sender, listing.nftId, listing.price);\n    }\n\n    /**\n     * @dev Set the marketplace fee percentage (in basis points)\n     * @param newFeePercentage The new fee percentage (100 = 1%, 10000 = 100%)\n     */\n    function setMarketplaceFee(uint256 newFeePercentage) external onlyOwner {\n        require(newFeePercentage <= 3000, \"Fee too high\"); // Max 30%\n        marketplaceFeePercentage = newFeePercentage;\n        emit MarketplaceFeeUpdated(newFeePercentage);\n    }\n\n    /**\n     * @dev Set the fee collector address\n     * @param newFeeCollector The new fee collector address\n     */\n    function setFeeCollector(address newFeeCollector) external onlyOwner {\n        require(newFeeCollector != address(0), \"Invalid address\");\n        feeCollector = newFeeCollector;\n        emit FeeCollectorUpdated(newFeeCollector);\n    }\n\n    /**\n     * @dev Pause the marketplace\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the marketplace\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // ==================== View Functions ====================\n\n    /**\n     * @dev Get all listings for a seller\n     * @param seller The address of the seller\n     * @return listingIds Array of listing IDs\n     */\n    function getSellerListings(address seller) external view returns (uint256[] memory) {\n        return sellerListings[seller];\n    }\n\n    /**\n     * @dev Get all active listings for a specific game item\n     * @param gameItemId The game item ID\n     * @return activeListingIds Array of active listing IDs\n     */\n    function getActiveGameItemListings(string memory gameItemId) external view returns (uint256[] memory) {\n        uint256 count = gameItemStats[gameItemId].currentListings;\n        uint256[] memory activeListingIds = new uint256[](count);\n\n        uint256 currentIndex = 0;\n        uint256 totalListings = _listingIds.current();\n\n        for (uint256 i = 1; i <= totalListings && currentIndex < count; i++) {\n            Listing storage listing = listings[i];\n            if (\n                listing.active &&\n                listing.itemType == ItemType.GAME_ITEM &&\n                keccak256(bytes(listing.gameItemId)) == keccak256(bytes(gameItemId))\n            ) {\n                activeListingIds[currentIndex] = i;\n                currentIndex++;\n            }\n        }\n\n        return activeListingIds;\n    }\n\n    /**\n     * @dev Get all active listings for a specific NFT\n     * @param nftId The NFT token ID\n     * @return activeListingIds Array of active listing IDs\n     */\n    function getActiveNftListings(uint256 nftId) external view returns (uint256[] memory) {\n        uint256 count = nftStats[nftId].currentListings;\n        uint256[] memory activeListingIds = new uint256[](count);\n\n        uint256 currentIndex = 0;\n        uint256 totalListings = _listingIds.current();\n\n        for (uint256 i = 1; i <= totalListings && currentIndex < count; i++) {\n            Listing storage listing = listings[i];\n            if (listing.active && listing.itemType == ItemType.NFT && listing.nftId == nftId) {\n                activeListingIds[currentIndex] = i;\n                currentIndex++;\n            }\n        }\n\n        return activeListingIds;\n    }\n\n    /**\n     * @dev Get the price history for a game item\n     * @param gameItemId The game item ID\n     * @param limit The maximum number of records to return (0 for all)\n     * @return records Array of price records\n     */\n    function getGameItemPriceHistory(\n        string memory gameItemId,\n        uint256 limit\n    ) external view returns (SaleRecord[] memory) {\n        SaleRecord[] storage history = gameItemSaleHistory[gameItemId];\n        uint256 historyLength = history.length;\n\n        if (limit == 0 || limit > historyLength) {\n            limit = historyLength;\n        }\n\n        SaleRecord[] memory records = new SaleRecord[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            // Get the most recent records first\n            records[i] = history[historyLength - limit + i];\n        }\n\n        return records;\n    }\n\n    /**\n     * @dev Get the price history for an NFT\n     * @param nftId The NFT token ID\n     * @param limit The maximum number of records to return (0 for all)\n     * @return records Array of price records\n     */\n    function getNftPriceHistory(uint256 nftId, uint256 limit) external view returns (SaleRecord[] memory) {\n        SaleRecord[] storage history = nftSaleHistory[nftId];\n        uint256 historyLength = history.length;\n\n        if (limit == 0 || limit > historyLength) {\n            limit = historyLength;\n        }\n\n        SaleRecord[] memory records = new SaleRecord[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            // Get the most recent records first\n            records[i] = history[historyLength - limit + i];\n        }\n\n        return records;\n    }\n\n    /**\n     * @dev Get the lowest priced listing for a game item\n     * @param gameItemId The game item ID\n     * @return listingId The listing ID with the lowest price\n     * @return price The lowest price\n     */\n    function getLowestPriceListingForGameItem(\n        string memory gameItemId\n    ) external view returns (uint256 listingId, uint256 price) {\n        listingId = lowestPriceListingForGameItem[gameItemId];\n\n        if (listingId != 0 && listings[listingId].active) {\n            price = listings[listingId].price;\n        } else {\n            price = 0;\n        }\n\n        return (listingId, price);\n    }\n\n    /**\n     * @dev Get the lowest priced listing for an NFT\n     * @param nftId The NFT token ID\n     * @return listingId The listing ID with the lowest price\n     * @return price The lowest price\n     */\n    function getLowestPriceListingForNft(uint256 nftId) external view returns (uint256 listingId, uint256 price) {\n        listingId = lowestPriceListingForNft[nftId];\n\n        if (listingId != 0 && listings[listingId].active) {\n            price = listings[listingId].price;\n        } else {\n            price = 0;\n        }\n\n        return (listingId, price);\n    }\n\n    /**\n     * @dev Get all unique game items that are currently listed in the marketplace\n     * @return uniqueGameItems Array of unique game item IDs\n     */\n    function getAllUniqueGameItems() external view returns (string[] memory) {\n        // Simply return the tracked unique game items\n        return uniqueGameItemIds;\n    }\n\n    /**\n     * @dev Get all unique NFTs that are currently listed in the marketplace\n     * @return uniqueNftIds Array of unique NFT IDs\n     */\n    function getAllUniqueNfts() external view returns (uint256[] memory) {\n        // Simply return the tracked unique NFT IDs\n        return uniqueNftIds;\n    }\n\n    /**\n     * @dev Get detailed information about a specific listing\n     * @param listingId The ID of the listing to retrieve\n     * @return The complete Listing struct containing all listing details\n     */\n    function getListingById(uint256 listingId) external view returns (Listing memory) {\n        require(listingId > 0 && listingId <= _listingIds.current(), \"Invalid listing ID\");\n        return listings[listingId];\n    }\n\n    /**\n     * @dev Get all unique items (both game items and NFTs) with their lowest prices\n     * @return gameItems Array of game item IDs\n     * @return gameItemPrices Array of lowest prices for each game item\n     * @return nftIds Array of NFT IDs\n     * @return nftPrices Array of lowest prices for each NFT\n     */\n    function getAllUniqueItemsWithPrices()\n        external\n        view\n        returns (\n            string[] memory gameItems,\n            uint256[] memory gameItemPrices,\n            uint256[] memory nftIds,\n            uint256[] memory nftPrices\n        )\n    {\n        // Get all unique game items\n        gameItems = this.getAllUniqueGameItems();\n        gameItemPrices = new uint256[](gameItems.length);\n\n        // Get lowest price for each game item\n        for (uint256 i = 0; i < gameItems.length; i++) {\n            (, uint256 price) = this.getLowestPriceListingForGameItem(gameItems[i]);\n            gameItemPrices[i] = price;\n        }\n\n        // Get all unique NFTs\n        nftIds = this.getAllUniqueNfts();\n        nftPrices = new uint256[](nftIds.length);\n\n        // Get lowest price for each NFT\n        for (uint256 i = 0; i < nftIds.length; i++) {\n            (, uint256 price) = this.getLowestPriceListingForNft(nftIds[i]);\n            nftPrices[i] = price;\n        }\n\n        return (gameItems, gameItemPrices, nftIds, nftPrices);\n    }\n\n    // ==================== Internal Functions ====================\n\n    /**\n     * @dev Verify if a user owns a game item\n     * @param user The user address\n     * @param gameItemId The game item ID\n     * @param quantity The quantity to verify\n     * @return Whether the user owns the specified quantity of the item\n     */\n    function _verifyGameItemOwnership(\n        address user,\n        string memory gameItemId,\n        uint256 quantity\n    ) internal view returns (bool) {\n        // Get only the inventory data needed for verification\n        GameSave.InventoryItem[] memory inventory = _getUserInventory(user);\n        uint256 ownedQuantity = 0;\n\n        // Sum up the quantity of matching items\n        for (uint i = 0; i < inventory.length; i++) {\n            if (keccak256(bytes(inventory[i].itemId)) == keccak256(bytes(gameItemId))) {\n                ownedQuantity += inventory[i].quantity;\n            }\n        }\n\n        return ownedQuantity >= quantity;\n    }\n\n    /**\n     * @dev Helper function to get only the inventory data needed for ownership verification\n     * @param user The user address\n     * @return inventory Array of user's inventory items\n     */\n    function _getUserInventory(address user) internal view returns (GameSave.InventoryItem[] memory) {\n        // Check if the user has a save in the GameSave contract\n        bool hasSave = gameSave.hasSaveData();\n\n        // If no save exists or the user isn't the caller, return an empty inventory\n        if (!hasSave || user != msg.sender) {\n            return new GameSave.InventoryItem[](0);\n        }\n\n        // Load only the inventory data from the GameSave contract\n        (\n            ,\n            ,\n            ,\n            // version (ignored)\n            // timestamp (ignored)\n            // player data (ignored)\n            GameSave.InventoryItem[] memory inventory, // farming data (ignored)\n            ,\n\n        ) = // map changes (ignored)\n            gameSave.loadGame();\n\n        return inventory;\n    }\n\n    /**\n     * @dev Update the lowest priced listing for a game item\n     * @param gameItemId The game item ID\n     * @param listingId The listing ID\n     * @param price The price\n     */\n    function _updateLowestPriceGameItemListing(string memory gameItemId, uint256 listingId, uint256 price) internal {\n        uint256 currentLowestListingId = lowestPriceListingForGameItem[gameItemId];\n\n        if (\n            currentLowestListingId == 0 ||\n            !listings[currentLowestListingId].active ||\n            price < listings[currentLowestListingId].price\n        ) {\n            lowestPriceListingForGameItem[gameItemId] = listingId;\n        }\n    }\n\n    /**\n     * @dev Update the lowest priced listing for an NFT\n     * @param nftId The NFT token ID\n     * @param listingId The listing ID\n     * @param price The price\n     */\n    function _updateLowestPriceNftListing(uint256 nftId, uint256 listingId, uint256 price) internal {\n        uint256 currentLowestListingId = lowestPriceListingForNft[nftId];\n\n        if (\n            currentLowestListingId == 0 ||\n            !listings[currentLowestListingId].active ||\n            price < listings[currentLowestListingId].price\n        ) {\n            lowestPriceListingForNft[nftId] = listingId;\n        }\n    }\n\n    /**\n     * @dev Recalculate the lowest priced listing for a game item\n     * @param gameItemId The game item ID\n     */\n    function _recalculateLowestPriceGameItemListing(string memory gameItemId) internal {\n        uint256 totalListings = _listingIds.current();\n        uint256 lowestPrice = type(uint256).max;\n        uint256 lowestPriceId = 0;\n\n        for (uint256 i = 1; i <= totalListings; i++) {\n            Listing storage listing = listings[i];\n            if (\n                listing.active &&\n                listing.itemType == ItemType.GAME_ITEM &&\n                keccak256(bytes(listing.gameItemId)) == keccak256(bytes(gameItemId)) &&\n                listing.price < lowestPrice\n            ) {\n                lowestPrice = listing.price;\n                lowestPriceId = i;\n            }\n        }\n\n        lowestPriceListingForGameItem[gameItemId] = lowestPriceId;\n    }\n\n    /**\n     * @dev Recalculate the lowest priced listing for an NFT\n     * @param nftId The NFT token ID\n     */\n    function _recalculateLowestPriceNftListing(uint256 nftId) internal {\n        uint256 totalListings = _listingIds.current();\n        uint256 lowestPrice = type(uint256).max;\n        uint256 lowestPriceId = 0;\n\n        for (uint256 i = 1; i <= totalListings; i++) {\n            Listing storage listing = listings[i];\n            if (\n                listing.active &&\n                listing.itemType == ItemType.NFT &&\n                listing.nftId == nftId &&\n                listing.price < lowestPrice\n            ) {\n                lowestPrice = listing.price;\n                lowestPriceId = i;\n            }\n        }\n\n        lowestPriceListingForNft[nftId] = lowestPriceId;\n    }\n\n    /**\n     * @dev Get the lowest price for a game item\n     * @param gameItemId The game item ID\n     * @return The lowest price\n     */\n    function _getLowestPriceForGameItem(string memory gameItemId) internal view returns (uint256) {\n        uint256 listingId = lowestPriceListingForGameItem[gameItemId];\n        if (listingId != 0 && listings[listingId].active) {\n            return listings[listingId].price;\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Get the lowest price for an NFT\n     * @param nftId The NFT token ID\n     * @return The lowest price\n     */\n    function _getLowestPriceForNft(uint256 nftId) internal view returns (uint256) {\n        uint256 listingId = lowestPriceListingForNft[nftId];\n        if (listingId != 0 && listings[listingId].active) {\n            return listings[listingId].price;\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Remove a game item from the unique items tracking when it has no active listings\n     * @param gameItemId The game item ID to remove\n     */\n    function _removeUniqueGameItem(string memory gameItemId) internal {\n        if (listedGameItems[gameItemId]) {\n            listedGameItems[gameItemId] = false;\n\n            // Find and remove the item from the uniqueGameItemIds array\n            for (uint256 i = 0; i < uniqueGameItemIds.length; i++) {\n                if (keccak256(bytes(uniqueGameItemIds[i])) == keccak256(bytes(gameItemId))) {\n                    // Move the last element to the position of the removed element\n                    if (i < uniqueGameItemIds.length - 1) {\n                        uniqueGameItemIds[i] = uniqueGameItemIds[uniqueGameItemIds.length - 1];\n                    }\n                    // Remove the last element\n                    uniqueGameItemIds.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Remove an NFT from the unique items tracking when it has no active listings\n     * @param nftId The NFT ID to remove\n     */\n    function _removeUniqueNft(uint256 nftId) internal {\n        if (listedNfts[nftId]) {\n            listedNfts[nftId] = false;\n\n            // Find and remove the NFT from the uniqueNftIds array\n            for (uint256 i = 0; i < uniqueNftIds.length; i++) {\n                if (uniqueNftIds[i] == nftId) {\n                    // Move the last element to the position of the removed element\n                    if (i < uniqueNftIds.length - 1) {\n                        uniqueNftIds[i] = uniqueNftIds[uniqueNftIds.length - 1];\n                    }\n                    // Remove the last element\n                    uniqueNftIds.pop();\n                    break;\n                }\n            }\n        }\n    }\n}\n"
    },
    "openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}